
## [189. Rotate Array](https://leetcode.com/problems/rotate-array/)

Given an integer array  `nums`, rotate the array to the right by  `k`  steps, where  `k`  is non-negative.

**Example 1:**

**Input:** nums = [1,2,3,4,5,6,7], k = 3
**Output:** [5,6,7,1,2,3,4]
**Explanation:**
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]

**Example 2:**

**Input:** nums = [-1,-100,3,99], k = 2
**Output:** [3,99,-1,-100]
**Explanation:** 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]

**Constraints:**

-   `1 <= nums.length <= 105`
-   `-231 <= nums[i] <= 231 - 1`
-   `0 <= k <= 105`
----------

## ðŸ§  Method 1: **Brute Force Rotation (Rotate One Step k Times)**

### Idea:
Rotate the array one step to the right, `k` times.  
Each step shifts elements by 1 place.  
Very simple but inefficient for large `k`.

----------

### Approach:

1.  For each `i` in range `k`:
    
    -   Save the last element.
        
    -   Shift all elements to the right by one index.
        
    -   Place the saved element at index `0`.
        

----------

### Algorithm:

1.  Repeat `k` times:
    
    -   Store `last = nums[n-1]`.
        
    -   For `j = n-1 â†’ 1`, move `nums[j] = nums[j-1]`.
        
    -   Place `nums[0] = last`.
        

----------

### Time Complexity:

-   `O(k * n)` â†’ **Very slow** for large arrays.
    

### Space Complexity:

-   `O(1)`
    

----------

### C++ Code:

```cpp
void rotate(vector<int>& nums, int k) 
{
    int n = nums.size();
    k %= n;
    for (int i = 0; i < k; i++) 
    {
        int last = nums[n - 1];
        for (int j = n - 1; j > 0; j--) 
        {
            nums[j] = nums[j - 1];
        }
        nums[0] = last;
    }
}

```
----------

## ðŸ§  Method 2: **Using Extra Array**

### Idea:

Use a **temporary array** to place each element directly at its new position `(i + k) % n`.

----------

### Approach:

1.  Create a new array `temp` of size `n`.
    
2.  Place element `nums[i]` at position `(i + k) % n` in `temp`.
    
3.  Copy `temp` back to `nums`.
    

----------

### Algorithm:

1.  `k = k % n`.
    
2.  Create `temp[n]`.
    
3.  For each index `i` in `nums`, place `temp[(i + k) % n] = nums[i]`.
    
4.  Copy `temp` to `nums`.
    

----------

### Time Complexity:

-   `O(n)`
    

### Space Complexity:

-   `O(n)` extra space.
    

----------

### C++ Code:

```cpp
void rotate(vector<int>& nums, int k) {
    int n = nums.size();
    k %= n;
    vector<int> temp(n);
    for (int i = 0; i < n; i++) {
        temp[(i + k) % n] = nums[i];
    }
    nums = temp;
}

```

----------

## ðŸ§  Method 3: **Reverse Array Method (Optimal)** âœ…

### Idea:

Rotating by `k` steps means:

1.  Reverse the entire array.
    
2.  Reverse first `k` elements.
    
3.  Reverse remaining `n-k` elements.
    

----------

### Approach:

Example: `nums = [1,2,3,4,5,6,7], k=3`

-   Reverse all â†’ `[7,6,5,4,3,2,1]`
    
-   Reverse first `3` â†’ `[5,6,7,4,3,2,1]`
    
-   Reverse last `4` â†’ `[5,6,7,1,2,3,4]`
    

----------

### Algorithm:

1.  `k = k % n`.
    
2.  Reverse `nums`.
    
3.  Reverse `nums[0..k-1]`.
    
4.  Reverse `nums[k..n-1]`.
    
----------

### Time Complexity:

-   `O(n)`
    

### Space Complexity:

-   `O(1)` â†’ **Best approach**.
    

----------

### C++ Code:

```cpp
void reverseArr(vector<int>& nums, int start, int end) 
{
    while (start < end) swap(nums[start++], nums[end--]);
}

void rotate(vector<int>& nums, int k) 
{
    int n = nums.size();
    k %= n;
    reverseArr(nums, 0, n - 1);
    reverseArr(nums, 0, k - 1);
    reverseArr(nums, k, n - 1);
}
```

----------

## ðŸ§  Method 4: **Cycle Replacements (O(n), O(1))**

### Idea:

-   Place each element directly in its correct position using **cycle detection**.
    
-   We track visited indices and place each number without extra space.
    

----------

### Approach:

1.  `k = k % n`.
    
2.  Start at index `0`.
    
3.  Move current element to `(current + k) % n`.
    
4.  Continue until we complete one cycle, then start next cycle from next unvisited index.
    

----------

### Algorithm:

```
count = 0
for start in 0..n-1:
    if count == n: break
    current = start
    prev = nums[start]
    do:
        next = (current + k) % n
        swap(prev, nums[next])
        current = next
        count++
    while start != current
```

----------

### Time Complexity:

-   `O(n)`
    

### Space Complexity
-   `O(1)`
    

----------

### C++ Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

void rotate(vector<int>& nums, int k) 
{
    int n = nums.size();
    k %= n;
    int count = 0;
    for (int start = 0; count < n; start++) 
    {
        int current = start;
        int prev = nums[start];
        do {
            int next = (current + k) % n;
            swap(nums[next], prev);
            current = next;
            count++;
        } while (start != current);
    }
}

```

----------

## ðŸ§© Corner Cases:

1.  `k = 0` â†’ Array remains same.
    
2.  `k >= n` â†’ Rotation same as `k % n`.
    
3.  `n = 1` â†’ Single element array, no change.
    
4.  `nums` with negative/large values (no effect).
    
5.  Very large `k` (up to `10^5`) â†’ Always reduce `k %= n`.
