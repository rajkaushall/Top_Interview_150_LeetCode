
## [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)
Given an integer array  `nums`  sorted in  **non-decreasing order**, remove the duplicates  [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm)  such that each unique element appears only  **once**. The  **relative order**  of the elements should be kept the  **same**. Then return  _the number of unique elements in_ `nums`.

Consider the number of unique elements of  `nums`  to be  `k`, to get accepted, you need to do the following things:

-   Change the array  `nums`  such that the first  `k`  elements of  `nums`  contain the unique elements in the order they were present in  `nums`  initially. The remaining elements of  `nums`  are not important as well as the size of  `nums`.
-   Return  `k`.

**Example 1:**

**Input:** nums = [1,1,2]
**Output:** 2, nums = [1,2,_]
**Explanation:** Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Example 2:**

**Input:** nums = [0,0,1,1,1,2,2,3,3,4]
**Output:** 5, nums = [0,1,2,3,4,_,_,_,_,_]
**Explanation:** Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Constraints:**

-   `1 <= nums.length <= 3 * 104`
-   `-100 <= nums[i] <= 100`
-   `nums`  is sorted in  **non-decreasing**  order.



## Method 1:  Two-Pointer / In-Place Overwrite (Optimal)

**Idea:**  
Since the array is sorted, duplicates are consecutive. We can use a **slow pointer** (`j`) to track the last unique element and a **fast pointer** (`i`) to traverse the array. When a new unique element is found, overwrite the next position of the slow pointer.

**Algorithm:**

1.  Initialize `j = 0` (last unique element).  
2.  Loop `i` from 1 to `n-1`.    
3.  If `nums[i] != nums[j]`:    
    -   Increment `j`.      
    -   Set `nums[j] = nums[i]`.        
4.  Return `j + 1`.
    

**C++ Code:**
```cpp
class Solution 
{
	public:
    int removeDuplicates(vector<int>& nums) 
    {
        if(nums.empty()) return 0;
        int j = 0; // last unique element
        for(int i = 1; i < nums.size(); i++) 
        {
            if(nums[i] != nums[j]) 
            {
                j++;
                nums[j] = nums[i];
            }
        }
        return j + 1;
    }
};

```

**Complexity:**
-   Time: O(n)   
-   Space: O(1)

## **Method 2:  Using `std::unique` (STL)**

**Idea:**  
C++ STL provides `std::unique` which removes consecutive duplicates and returns an iterator to the new end. This method is **concise** but relies on STL.

**Algorithm:**

1.  Call `auto it = std::unique(nums.begin(), nums.end())`.    
2.  The distance between `nums.begin()` and `it` is the new length.
    

**C++ Code:**

```cpp
class Solution 
{
	public:
    int removeDuplicates(vector<int>& nums) 
    {
        auto it = std::unique(nums.begin(), nums.end());
        return distance(nums.begin(), it);
    }
};
 ```

**Complexity:**
-   Time: O(n)   
-   Space: O(1)
    

----------

## **Method 3: Using Extra Array / Vector**

**Idea:**  
Create a new vector to store unique elements. This is **easy but not in-place**.

**Algorithm:**
1.  Initialize `vector<int> uniqueNums`.    
2.  Traverse `nums`: if current element != last element in `uniqueNums`, push it.    
3.  Copy `uniqueNums` back to `nums`.    
4.  Return `uniqueNums.size()`.
    

**C++ Code:**
```cpp
class Solution 
{
	public:
    int removeDuplicates(vector<int>& nums) 
    {
        if(nums.empty()) return 0;
        vector<int> uniqueNums;
        uniqueNums.push_back(nums[0]);
        for(int i = 1; i < nums.size(); i++) 
        {
            if(nums[i] != uniqueNums.back()) 
            {
                uniqueNums.push_back(nums[i]);
            }
        }
        for(int i = 0; i < uniqueNums.size(); i++) 
        {
            nums[i] = uniqueNums[i];
        }
        return uniqueNums.size();
    }
};

```

**Complexity:**
-   Time: O(n)    
-   Space: O(n) (extra array)


## **Method 4: Naive Approach (Erase Method)**

**Idea:**  
Iterate and **erase duplicates** whenever found. Very intuitive but **inefficient** because `erase` shifts elements.

**Algorithm:**
1.  Loop from `i = 1` to `nums.size() - 1`.    
2.  If `nums[i] == nums[i-1]`, erase `nums[i]` and decrease `i`.
    

**C++ Code:**
```cpp
class Solution 
{
	public:
    int removeDuplicates(vector<int>& nums) 
    {
        if(nums.empty()) return 0;
        for(int i = 1; i < nums.size(); ) 
        {
            if(nums[i] == nums[i-1]) 
            {
                nums.erase(nums.begin() + i);
            } 
            else 
            {
                i++;
            }
        }
        return nums.size();
    }
};

```

**Complexity:**
-   Time: O(nÂ²) (inefficient for large arrays)    
-   Space: O(1)
