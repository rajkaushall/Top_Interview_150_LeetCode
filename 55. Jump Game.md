
## [55. Jump Game](https://leetcode.com/problems/jump-game/)
You are given an integer array  `nums`. You are initially positioned at the array's  **first index**, and each element in the array represents your maximum jump length at that position.

Return  `true` _if you can reach the last index, or_ `false` _otherwise_.

**Example 1:**

**Input:** nums = [2,3,1,1,4]
**Output:** true
**Explanation:** Jump 1 step from index 0 to 1, then 3 steps to the last index.

**Example 2:**

**Input:** nums = [3,2,1,0,4]
**Output:** false
**Explanation:** You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.

**Constraints:**

-   `1 <= nums.length <= 104`
-   `0 <= nums[i] <= 105`
---
üß© **Greedy Idea:**  
Instead of exploring every jump path (which is slow), track the **farthest index** you can reach at each step:

-   If you ever reach an index that is **beyond your max reach**, stop ‚Üí `false`.
    
-   Keep updating `maxReach = max(maxReach, i + nums[i])`.
    
-   If `maxReach` covers the last index, return `true`.
    

----------

‚öôÔ∏è **Steps to Solve:**  
1Ô∏è‚É£ Initialize `maxReach = 0`.  
2Ô∏è‚É£ Traverse through each index `i`:

-   If `i > maxReach`, we‚Äôre stuck ‚Üí `false`.
    
-   Else, update `maxReach`.  
    3Ô∏è‚É£ If at any point `maxReach >= lastIndex`, return `true`.
    

----------

üíª **Code (C++):**

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) 
    {
        int maxReach = 0;
        for (int i = 0; i < nums.size(); i++) 
        {
            if (i > maxReach) return false;
            maxReach = max(maxReach, i + nums[i]);
            if (maxReach >= nums.size() - 1) return true;
        }
        return true;
    }
};

```

----------

‚è≥ **Complexity:**

-   **Time:** O(n) ‚Äì Single pass through the array
    
-   **Space:** O(1) ‚Äì Constant memory usage
