
## [27. Remove Element](https://leetcode.com/problems/remove-element/)


Given an integer array  `nums`  and an integer  `val`, remove all occurrences of  `val`  in  `nums`  [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return  _the number of elements in_ `nums` _which are not equal to_ `val`.

Consider the number of elements in  `nums`  which are not equal to  `val`  be  `k`, to get accepted, you need to do the following things:

-   Change the array  `nums`  such that the first  `k`  elements of  `nums`  contain the elements which are not equal to  `val`. The remaining elements of  `nums`  are not important as well as the size of  `nums`.
-   Return  `k`.

**Example 1:**

**Input:** nums = [3,2,2,3], val = 3
**Output:** 2, nums = [2,2,_,_]
**Explanation:** Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Example 2:**

**Input:** nums = [0,1,2,2,3,0,4,2], val = 2
**Output:** 5, nums = [0,1,4,0,3,_,_,_]
**Explanation:** Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).

**Constraints:**

-   `0 <= nums.length <= 100`
-   `0 <= nums[i] <= 50`
-   `0 <= val <= 100`

---
## **1️⃣ Remove-erase idiom (Recommended, Modern C++)**
```cpp
class  Solution 
{
	public:
	int  removeElement(vector<int>&  nums, int  val) 
	{
		nums.erase(remove(nums.begin(), nums.end(), val), nums.end());
		return  nums.size();
	}
};
```

✅ Removes **all occurrences** of `val`.  
✅ Very safe and efficient.

----------

## **2️⃣ Iterator-based loop**
```cpp
class Solution 
{
	public:
    int removeElement(vector<int>& nums, int val) 
    {
        for(auto it = nums.begin(); it != nums.end(); ) 
        {
            if(*it == val)
                it = nums.erase(it);
            else
                ++it;
        }
        return nums.size();
    }
};
```

✅ Safe for **multiple removals**.  
✅ Works well if you want **custom logic** during iteration.



## **3️⃣ Index-based loop (Backwards)**

-   Agar aap **normal for loop** use karte ho, to **reverse loop** karna safe hai.
```cpp
class Solution 
{
	public:
    int removeElement(vector<int>& nums, int val) 
    {
        for(int i = nums.size() - 1; i >= 0; --i) 
        {
            if(nums[i] == val)
                nums.erase(nums.begin() + i);
        }
        return nums.size();
    }
};
```

✅ Backwards loop ensures **erasing elements doesn’t skip any**.


## **4️⃣ Using temporary vector (Copy approach)**

```cpp
class Solution 
{
	public:
    int removeElement(vector<int>& nums, int val) 
    {
        vector<int> temp;
        for(int x : nums) 
        {
            if(x != val)
                temp.push_back(x);
        }
        nums = temp;
        return nums.size();
    }
};
```

✅ Safe, simple, and easy to understand.  
❌ Uses extra memory.

----------

## **5️⃣ Two-pointer technique (In-place, no erase)**

-   Common in LeetCode problems like “Remove Element”.   
-   Works **without erase**, very fast.
```cpp
class Solution 
{
	public:
    int removeElement(vector<int>& nums, int val) 
    {
        int k = 0; // pointer for placement
        for(int i = 0; i < nums.size(); ++i) 
        {
            if(nums[i] != val) 
            {
                nums[k] = nums[i];
                k++;
            }
        }
        return k; // new length of array
    }
};

```

✅ Efficient (O(n)), no extra memory.  
✅ Useful in competitive programming.
