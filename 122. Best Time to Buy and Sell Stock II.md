
## [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)
You are given an integer array  `prices`  where  `prices[i]`  is the price of a given stock on the  `ith`  day.

On each day, you may decide to buy and/or sell the stock. You can only hold  **at most one**  share of the stock at any time. However, you can buy it then immediately sell it on the  **same day**.

Find and return  _the  **maximum**  profit you can achieve_.

**Example 1:**

**Input:** prices = [7,1,5,3,6,4]
**Output:** 7
**Explanation:** Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.

**Example 2:**

**Input:** prices = [1,2,3,4,5]
**Output:** 4
**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Total profit is 4.

**Example 3:**

**Input:** prices = [7,6,4,3,1]
**Output:** 0
**Explanation:** There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.

**Constraints:**

-   `1 <= prices.length <= 3 * 104`
-   `0 <= prices[i] <= 104`
- ---
## üî• Problem Summary:

We want to **maximize total profit**.  
We can **buy and sell multiple times**, but can hold **only one stock at a time**.  
We can also **buy and sell on the same day** (effectively skipping transactions).

----------

# üîπ 1. Brute Force (Try all combinations)

### üí° Idea:

-   For every day, try **buying** and **selling** at all future days.
    
-   Recursively explore every possible transaction combination.
    
-   Take the maximum profit across all possibilities.
    

----------

### üìù Algorithm:

1.  Start at index `i = 0`.
    
2.  For every day `i`, try:
    
    -   Buy stock at `i`.
        
    -   For every `j > i`, if `prices[j] > prices[i]`, sell at `j`.
        
    -   Add `profit = prices[j] - prices[i]`.
        
    -   Recursively calculate max profit from `j+1`.
        
3.  Keep track of max profit.
    

----------

### üß© Code (C++):
```cpp
class Solution 
{
	public:
    int solve(vector<int>& prices, int start) 
    {
        if (start >= prices.size()) return 0;
        int maxProfit = 0;
        for (int i = start; i < prices.size() - 1; i++) 
        {
            for (int j = i + 1; j < prices.size(); j++) 
            {
                if (prices[j] > prices[i]) 
                {
                    int profit = prices[j] - prices[i] + solve(prices, j + 1);
                    maxProfit = max(maxProfit, profit);
                }
            }
        }
        return maxProfit;
    }
    int maxProfit(vector<int>& prices) {
        return solve(prices, 0);
    }
};

```

----------

### ‚è≥ Complexity:

-   **Time:** O(n¬≤ * n) ‚Üí worst-case **O(n¬≥)** (due to nested loops and recursion)
    
-   **Space:** O(n) (recursion stack)
    

‚ö†Ô∏è **Not practical for large inputs (n ‚â§ 30k)**, but good for understanding the problem deeply.

----------

# üîπ 2. Greedy Approach (Optimal & Easiest)

### üí° Idea:

-   We only need to **sum up every upward price difference**.
    
-   If `prices[i+1] > prices[i]`, add `prices[i+1] - prices[i]` to profit.
    
-   This works because multiple small profitable trades = one big trade.
    

----------

### üìù Algorithm:

1.  Initialize `profit = 0`.
    
2.  Loop through `prices`:
    
    -   If `prices[i+1] > prices[i]`, add difference to `profit`.
        
3.  Return `profit`.
    

----------

### üß© Code (C++):

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        for (int i = 1; i < prices.size(); i++) {
            if (prices[i] > prices[i - 1])
                profit += prices[i] - prices[i - 1];
        }
        return profit;
    }
};

```

----------

### ‚è≥ Complexity:

-   **Time:** O(n)
    
-   **Space:** O(1)
    

‚úÖ **Best solution** for this problem.

----------

# üîπ 3. Dynamic Programming (DP Table)

### üí° Idea:

-   At each day, we have **2 states**:
    
    1.  **Hold stock** (buy or continue holding)
        
    2.  **Not holding stock** (sell or skip)
        
-   Use DP to compute maximum profit at each step.
    

----------

### üìù DP Transition:

Let:

-   `dp[i][0]`: Max profit on day `i` **without stock**.
    
-   `dp[i][1]`: Max profit on day `i` **with stock**.
    

Recurrence:
```
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])  // Sell or do nothing
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])  // Buy or do nothing

```

----------

### üß© Code (C++):

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] = 0;          // No stock on day 0
        dp[0][1] = -prices[0]; // Bought stock on day 0
        
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
        }
        return dp[n-1][0];
    }
};

```

----------

### ‚è≥ Complexity:

-   **Time:** O(n)
    
-   **Space:** O(n) (can be optimized to O(1))
    

----------

# üîπ 4. DP with Space Optimization

We only need **previous day values**.

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int hold = -prices[0], notHold = 0;
        for (int i = 1; i < prices.size(); i++) {
            int prevHold = hold;
            hold = max(hold, notHold - prices[i]);
            notHold = max(notHold, prevHold + prices[i]);
        }
        return notHold;
    }
};

```

----------

### ‚è≥ Complexity:

-   **Time:** O(n)
    
-   **Space:** O(1)
    

----------

# üîπ 5. Recursion + Memoization

### üí° Idea:

-   Similar to DP, but use recursion.
    
-   At each day, choose to:
    
    1.  **Buy**, **Sell**, or **Skip**.
        
-   Store results in a memo table to avoid recomputation.
    

----------

### üß© Code:

```cpp
class Solution {
public:
    int solve(vector<int>& prices, int i, bool canBuy, vector<vector<int>>& memo) {
        if (i >= prices.size()) return 0;
        if (memo[i][canBuy] != -1) return memo[i][canBuy];

        int profit = 0;
        if (canBuy) {
            profit = max(-prices[i] + solve(prices, i+1, false, memo),
                         solve(prices, i+1, true, memo));
        } else {
            profit = max(prices[i] + solve(prices, i+1, true, memo),
                         solve(prices, i+1, false, memo));
        }
        return memo[i][canBuy] = profit;
    }

    int maxProfit(vector<int>& prices) {
        vector<vector<int>> memo(prices.size(), vector<int>(2, -1));
        return solve(prices, 0, true, memo);
    }
};

```

----------

### ‚è≥ Complexity:

-   **Time:** O(n*2) ‚Üí O(n)  
-   **Space:** O(n) (recursion + memo)
