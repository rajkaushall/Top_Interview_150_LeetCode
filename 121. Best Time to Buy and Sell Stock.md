
## [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
You are given an array  `prices`  where  `prices[i]`  is the price of a given stock on the  `ith`  day.

You want to maximize your profit by choosing a  **single day**  to buy one stock and choosing a  **different day in the future**  to sell that stock.

Return  _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return  `0`.

**Example 1:**

**Input:** prices = [7,1,5,3,6,4]
**Output:** 5
**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.

**Example 2:**

**Input:** prices = [7,6,4,3,1]
**Output:** 0
**Explanation:** In this case, no transactions are done and the max profit = 0.

**Constraints:**

-   `1 <= prices.length <= 105`
-   `0 <= prices[i] <= 104`
- ----
üß© **Idea Behind My Approach:**  
I started by thinking:

> ‚ÄúWhat if I track the **lowest price so far** as a potential buying day and calculate profit if I sold today?‚Äù  
> This way, instead of comparing every pair of days (O(n¬≤)), I only need **one pass** through the array.

I initially attempted a `mnp` (min price index) and `mxp` (max price index) approach, but it failed for cases where the highest price appeared **before** the minimum price.  
üîë Key Insight: Instead of tracking indices separately, we only need:

-   `minPrice`: lowest price seen so far
    
-   `maxProfit`: best profit found so far
    

----------

‚öôÔ∏è **Steps I Used to Solve It Efficiently (O(n)):**  
1Ô∏è‚É£ Initialize `minPrice = prices[0]`, `maxProfit = 0`.  
2Ô∏è‚É£ Loop through the array:

-   Update `maxProfit = max(maxProfit, prices[i] - minPrice)`
    
-   Update `minPrice = min(minPrice, prices[i])`  
3Ô∏è‚É£ Return `maxProfit` at the end.
    

----------

üîç **Difficulty Faced:**  
At first, I wrote a version that tracked both min and max indices (`mnp`, `mxp`), but it failed for scenarios like:  
`[3, 2, 6, 5, 0, 3]`

-   It returned `6` instead of `3` because it considered selling **before** buying!  
    Debugging this helped me realize the **temporal constraint** (buy before sell) is key.
    

----------

‚ö†Ô∏è **Corner Cases Considered:**  
‚úÖ All prices decreasing ‚Üí Profit is `0`.  
‚úÖ Array of size `1` ‚Üí No transactions possible.  
‚úÖ Prices staying the same ‚Üí Profit remains `0`.  
‚úÖ Prices increasing throughout ‚Üí Buy on Day 1, sell on last day.

----------
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) 
    {
        int minPrice = prices[0];
        int maxProfit = 0;

        for(int i = 1; i < prices.size(); i++) 
        {
            maxProfit = max(maxProfit, prices[i] - minPrice);
            minPrice = min(minPrice, prices[i]);
        }
        return maxProfit;
    }
};

```

üìà **Time Complexity:** O(n) | **Space Complexity:** O(1)
